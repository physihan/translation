几个星期以前，我在希思罗机场飞机起飞之前忙点事情，
然后我发现github的表现有点奇怪：在新页面打开链接
比直接在当前页点击链接打开要快，这是我当时录下的
[![IMAGE ALT TEXT](https://i.ytimg.com/vi_webp/4zG0AZRZD6Q/sddefault.webp)](https://i.ytimg.com/vi_webp/4zG0AZRZD6Q/sddefault.webp)

background-image: url("https://i.ytimg.com/vi_webp/4zG0AZRZD6Q/sddefault.webp");
这里我点击了一个链接，然后在一个新页面把这个链接粘贴进去，虽然这个页面是后打开的，但新页面渲染的更快。
## showthem what you got
<figure class="full-figure connection-diagram blueprint animate-diagram" style="background-color: #0065a4">
<svg viewBox="0 0 1920 1000">
  <g fill="#fff">
    <path d="M1594 148.6h173c14.5 0 26-11.4 26-26 0-14.5-11.5-26-26-26h-173c-14.5 0-26 11.5-26 26 0 14.6 11.5 26 26 26zm130-32h46.7c3 0 6.2 3 6.2 6s-3.2 6-6.3 6H1724c-3 0-6-3-6-6s3-6 6-6zm-88 0h15.4c3 0 6.2 3 6.2 6s-3 6-6.2 6H1636c-3 0-6-3-6-6s3-6 6-6zm-39.6 0h15.3c3 0 6 3 6 6s-3 6-6 6h-15.3c-3 0-6.2-3-6.2-6s2.3-6 6.2-6zM1767 225h-173c-14.5 0-26 11.6-26 26 0 14.7 11.5 26 26 26h173c14.5 0 26-11.3 26-26 0-14.4-11.5-26-26-26zm-155.3 32.2h-15.3c-3 0-6.2-3-6.2-6s3-6.2 6.2-6.2h15.3c3 0 6 3 6 6 0 3.2-3 6.2-6 6.2zm40.5 0H1637c-3.2 0-6.2-3-6.2-6s3-6.2 6-6.2h15.4c3 0 6 3 6 6 0 3.2-3 6.2-6 6.2zm118.5 0H1724c-3 0-6-3-6-6s3-6.2 6-6.2h46.7c3 0 6.2 3 6.2 6 0 3.2-3.2 6.2-6.3 6.2zM1767 161h-173c-14.5 0-26 11.3-26 26 0 14.4 11.5 26 26 26h173c14.5 0 26-11.6 26-26 0-14.7-11.5-26-26-26zm-155.3 32h-15.3c-3 0-6.2-3-6.2-6 0-3.2 3-6.2 6.2-6.2h15.3c3 0 6 3 6 6 0 4-3 6.2-6 6.2zm40.5 0H1637c-3.2 0-6.2-3-6.2-6 0-3.2 3-6.2 6-6.2h15.4c3 0 6 3 6 6 0 4-3 6.2-6 6.2zm118.5 0H1724c-3 0-6-3-6-6 0-3.2 3-6.2 6-6.2h46.7c3 0 6.2 3 6.2 6 0 4-3.2 6.2-6.3 6.2zM1761.6 321.5h-75v-33.7h-12.2v33.7h-75c-3 0-6 3-6 6 0 3.2 3 6.2 6 6.2h161.4c3 0 6-3 6-6 1-3.2-2.2-6.2-5.2-6.2z"></path>
  </g>
  <path class="connection-path" d="M423.7 765.3c538.6-.7 725.8-446.7 1153.7-438.5" fill="none" stroke="#fff" stroke-width="12.1" stroke-dasharray="12.1 24.2"></path>
  <g transform="matrix(.68416 0 0 .68416 -214.763 495.975)">
    <path class="page-img" fill="none" stroke="#fff" stroke-width="13.58414" stroke-linecap="round" stroke-linejoin="round" d="M661.7 266.5H539.5v102h122.2z"></path>
    <clipPath class="page-loading" id="a">
      <path fill="#fff" d="M518.8 252.7H883v235H519z"></path>
    </clipPath>
    <g clip-path="url(#a)" class="page-text" fill="none" stroke="#fff" stroke-width="13.6" stroke-linecap="round" stroke-linejoin="round">
      <path d="M695.7 300.5h74.7M797.6 300.5h68M695.7 334.4H811M838.3 334.4h27.2M695.7 266.5H811M838.3 266.5h27.2M695.7 436.3h74.7M797.6 436.3h68M695.7 368.4h74.7M797.6 368.4h68M702.5 402.4h34M763.6 402.4h102M539.5 402.4H621M648 402.4h27.3M702.5 470.3H811M838.3 470.3h27.2M539.5 470.3H621M648 470.3h27.3M539.5 436.3h20.3M587 436.3h81.5"></path>
    </g>
    <path d="M899.4 504.2h-394V259.7c0-15 12.3-27 27.3-27h339.6c15 0 27 12 27 27v244.5zM872.3 558.6H532.7c-15 0-27.2-12.2-27.2-27.2v-27.2h394v27.2c0 15-12.2 27.2-27.2 27.2z" fill="none" stroke="#fff" stroke-width="13.6" stroke-linecap="round" stroke-linejoin="round"></path>
    <path fill="none" stroke="#fff" stroke-width="13.58414" stroke-linecap="round" stroke-linejoin="round" d="M641.3 626.5l20.4-68h81.5l20.4 68z"></path>
    <path d="M777.2 626.5H627.8" fill="none" stroke="#fff" stroke-width="13.6" stroke-linecap="round" stroke-linejoin="round"></path>
  </g>
</svg>
</figure>  
当你加载一个页面时，浏览器获取一个网络流，然后加载进html parser中，然后再将转换的内容输出到document中。
这意味着页面可以在下载的同时一点一点的加载，这个页面可能有100k大，但是可以渲染内容即使只接受到20k的数据。  
这是一个伟大的、久远的浏览器特性，但是作为开发者我们经常抛弃这种特性。大多数加载时的性能建议可以归结为“你得到多少
就展示多少”，不要停滞，不要等到所有东西都加载好后才展示给用户看。  
GitHub关心性能，所以使用服务器端渲染页面。然而在同一个tab页面跳转就是使用javascript重新实现了一遍，就想下面代码这样。。

```javascript
// …lots of code to reimplement browser navigation…
const response = await fetch('page-data.inc');
const html = await response.text();
document.querySelector('.content').innerHTML = html;
// …loads more code to reimplement browser navigation…

```
这不符合规则，因为所有的`page-data.inc'会预先下载在所有东西完成之前
服务器端渲染不会以这种方式保存内容，它会以数据流的形式加速渲染。对于GitHub的客户端渲染，大量的javascript代码使这个
变得缓慢。  
我在这里只是用GitHub作为一个例子，这种不好的模式几乎在所有的单页面应用内都在使用。  
在页面内切换内容有一些优点，尤其是页面内加载了很大很重的scripts，因为你可以更新页面
内容而不用重新部署所有的js。但是我们可不可以那样做而且继续使用streaming？我以前总说
JavaScript不能访问stream parser，但它却是。。
## 使用iframes和document.write来改善性能
最糟糕的是涉及到了`<iframe>`,而且这一次用到了`<iframe>`和`document.write`
但确实实现了以数据流的形式加载页面，代码是这样的：

```javascript
// Create an iframe:
const iframe = document.createElement('iframe');

// Put it in the document (but hidden):
iframe.style.display = 'none';
document.body.appendChild(iframe);

// Wait for the iframe to be ready:
iframe.onload = () => {
  // Ignore further load events:
  iframe.onload = null;

  // Write a dummy tag:
  iframe.contentDocument.write('<streaming-element>');

  // Get a reference to that element:
  const streamingElement = iframe.contentDocument.querySelector('streaming-element');

  // Pull it out of the iframe & into the parent document:
  document.body.appendChild(streamingElement);

  // Write some more content - this should be done async:
  iframe.contentDocument.write('<p>Hello!</p>');

  // Keep writing content like above, and then when we're done:
  iframe.contentDocument.write('</streaming-element>');
  iframe.contentDocument.close();
};

// Initialise the iframe
iframe.src = '';
```
尽管`<p>Hello!</p>`写在了`iframe`里边，但它出现在父文档里面！这是
因为[html parser](https://html.spec.whatwg.org/multipage/syntax.html#parsing)